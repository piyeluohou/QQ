// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include "common/common_utils/StrictMode.hpp"
STRICT_MODE_OFF
#ifndef RPCLIB_MSGPACK
#define RPCLIB_MSGPACK clmdep_msgpack
#endif // !RPCLIB_MSGPACK
#include "rpc/rpc_error.h"
STRICT_MODE_ON
int q = 0; //计数器
int s = 0;
int p = 0;
#include "vehicles/multirotor/api/MultirotorRpcLibClient.hpp"
#include "common/common_utils/FileSystem.hpp"
#include <iostream>
#include <chrono>
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <vector>
#include <opencv2\imgproc\types_c.h>
#include "../../AirLib/include/common/PidController.hpp"
//#include "E:\visual studio\NEWQQ\AirLib\include\common\CommonStructs.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "D:\qq\AirLib\include\common\CommonStructs.hpp"

#include <math.h>
#include <string.h>
#define elemType int 

using namespace cv;
using namespace std;
int thresh = 50, N = 5;
const char* wndname = "Square Detection Demo";

// helper function:
// finds a cosine of angle between vectors
// from pt0->pt1 and from pt0->pt2
static double angle(Point pt1, Point pt2, Point pt0)
{
    double dx1 = pt1.x - pt0.x;
    double dy1 = pt1.y - pt0.y;
    double dx2 = pt2.x - pt0.x;
    double dy2 = pt2.y - pt0.y;
    return (dx1 * dx2 + dy1 * dy2) / sqrt((dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2) + 1e-10);
}


int getColSum(Mat src, int col)//统计所有列像素的总和
{
    int sum = 0;
    int height = src.rows;
    int width = src.cols;
    for (int i = 0; i < height; i++)
    {
        sum = sum + src.at <uchar>(i, col);
    }
    return sum;
}

int getRowSum(Mat src, int row)//统计所有行像素的总和
{
    int sum = 0;
    int height = src.rows;
    int width = src.cols;
    for (int i = 0; i < width; i++)
    {
        sum += src.at <uchar>(row, i);
    }
    return sum;
}
int cutLeft(Mat& src, Mat& leftImg)//左右切割
{
    int left, right;
    left = 0;
    right = src.cols;

    int i;
    for (i = 1; i < src.cols; i++)
    {
        int colValue = getColSum(src, i);//统计所有列像素的总和
        //cout <<i<<" th "<< colValue << endl;
        if (colValue > 0)//扫描直到列像素的总和大于0时，记下当前位置left
        {
            left = i;
            break;
        }
    }

    if (left == 0)
    {
        return 1;
    }

    //继续扫描
    for (; i < src.cols; i++)
    {
        int colValue = getColSum(src, i);//统计所有列像素的总和
        //cout << i << " th " << colValue << endl;
        if (colValue == 0)//继续扫描直到列像素的总和等于0时，记下当前位置right
        {
            right = i;
            break;
        }
    }
    int width = right - left;//分割图片的宽度则为right - left
    Rect rect(left, 0, width, src.rows);//构造一个矩形，参数分别为矩形左边顶部的X坐标、Y坐标，右边底部的X坐标、Y坐标（左上角坐标为0，0）
    leftImg = src(rect).clone();

    return 0;
}


void cutTop(Mat& src, Mat& dstImg)//上下切割
{
    int top, bottom;
    top = 1;
    bottom = src.rows;

    int i;
    for (i = src.rows - 1; i > 0; i--)
    {
        int colValue = getRowSum(src, i);//统计所有行像素的总和
        //cout <<i<<" th "<< colValue << endl;
        if (colValue > 0)//扫描直到行像素的总和大于0时，记下当前位置
        {
            bottom = i;
            break;
        }
    }
    for (; i > 0; i--)
    {
        int colValue = getRowSum(src, i);//统计所有行像素的总和
        //cout << i << " th " << colValue << endl;
        if (colValue == 0)//继续扫描直到行像素的总和等于0时，记下当前位置bottom
        {
            top = i;
            break;
        }
    }

    int height = bottom - top;
    Rect rect(0, top, src.cols, height);
    dstImg = src(rect).clone();
    cutLeft(dstImg, dstImg);//上下切割
}



// returns sequence of squares detected on the image.
// the sequence is stored in the specified memory storage
static void findSquares(const Mat& image, std::vector<std::vector<Point> >& squares)
{
    squares.clear();

    //s    Mat pyr, timg, gray0(image.size(), CV_8U), gray;

        // down-scale and upscale the image to filter out the noise
        //pyrDown(image, pyr, Size(image.cols/2, image.rows/2));
        //pyrUp(pyr, timg, image.size());


        // blur will enhance edge detection
    Mat timg(image);
    Mat gray0(timg.size(), CV_8U), gray;

    std::vector<std::vector<Point> > contours;

    // find squares in every color plane of the image
    for (int c = 0; c < 3; c++)
    {
        int ch[] = { c, 0 };
        mixChannels(&timg, 1, &gray0, 1, ch, 1);

        // try several threshold levels
        for (int l = 0; l < N; l++)
        {
            // hack: use Canny instead of zero threshold level.
            // Canny helps to catch squares with gradient shading
            if (l == 0)
            {
                // apply Canny. Take the upper threshold from slider
                // and set the lower to 0 (which forces edges merging)
                Canny(gray0, gray, 5, thresh, 5);
                // dilate canny output to remove potential
                // holes between edge segments
                dilate(gray, gray, Mat(), Point(-1, -1));
            }
            else
            {
                // apply threshold if l!=0:
                //     tgray(x,y) = gray(x,y) < (l+1)*255/N ? 255 : 0
                gray = gray0 >= (l + 1) * 255 / N;
            }

            // find contours and store them all as a list
            findContours(gray, contours, RETR_LIST, CHAIN_APPROX_SIMPLE);

            std::vector<Point> approx;

            // test each contour
            for (size_t i = 0; i < contours.size(); i++)
            {
                // approximate contour with accuracy proportional
                // to the contour perimeter
                approxPolyDP(Mat(contours[i]), approx, arcLength(Mat(contours[i]), true) * 0.02, true);

                // square contours should have 4 vertices after approximation
                // relatively large area (to filter out noisy contours)
                // and be convex.
                // Note: absolute value of an area is used because
                // area may be positive or negative - in accordance with the
                // contour orientation
                if (approx.size() == 4 &&
                    fabs(contourArea(Mat(approx))) > 1000 &&
                    isContourConvex(Mat(approx)))
                {
                    double maxCosine = 0;

                    for (int j = 2; j < 5; j++)
                    {
                        // find the maximum cosine of the angle between joint edges
                        double cosine = fabs(angle(approx[j % 4], approx[j - 2], approx[j - 1]));
                        maxCosine = MAX(maxCosine, cosine);
                    }

                    // if cosines of all angles are small
                    // (all angles are ~90 degree) then write quandrange
                    // vertices to resultant sequence
                    if (maxCosine < 0.4)
                        squares.push_back(approx);
                }
            }
        }
    }
}


// the function draws all the squares in the image
static void drawSquares(Mat& image, const std::vector<std::vector<Point> >& squares)
{

    for (size_t i = 0; i < squares.size(); i++)
    {
        const Point* p = &squares[i][0];
        int n = (int)squares[i].size();
        //dont detect the border
        if (p->x > 3 && p->y > 3)
            polylines(image, &p, &n, 1, true, Scalar(0, 255, 0), 3, LINE_AA);
    }


}


void getPXSum(Mat& src, int& a)//获取所有像素点和
{
    threshold(src, src, 100, 255, CV_THRESH_BINARY);
    a = 0;
    for (int i = 0; i < src.rows; i++)
    {
        for (int j = 0; j < src.cols; j++)
        {
            a += src.at <uchar>(i, j);
        }
    }
}

int diff = 0;
int serieNum = 0;
int  getSubtract(Mat& src, int TemplateNum) //数字识别
{
    Mat img_result;
    int min = 100000000;


    //threshold(src, src, 100, 255, CV_THRESH_BINARY);

    char name[50];
    int i = 0; int se = 0;
    for (; i < 10; i++) {
        int diff1 = 0, diff2 = 0;
        sprintf_s(name, "%d.jpg", i);
        Mat Template = imread(name, CV_LOAD_IMAGE_GRAYSCALE);//读取模板
        threshold(Template, Template, 100, 255, CV_THRESH_BINARY_INV);
        cutTop(Template, Template);
        resize(Template, Template, Size(620, 480));//调整尺寸

        cv::imshow("模板数字", Template);
        cv::imshow("要识别的数字", src);
        cv::waitKey(100);
        //getPXSum(Template, diff1);
        //getPXSum(src, diff2);
        /*让需要匹配的图分别和10个模板对应像素点值相减，然后求返回图片的整个图片的像素点值得平方和，和哪个模板匹配时候返回图片的平方和最小则就可以得到结果*/
        absdiff(Template, src, img_result);//AbsDiff，OpenCV中计算两个数组差的绝对值的函数。
        getPXSum(img_result, diff);//获取所有像素点和
        std::cout << diff << endl;
        if (diff < min)//像素点对比
        {
            min = diff;
            se = i;
            cout << se << endl;
        }
    }
    if (min > 28000000)
    {
        std::printf("没匹配到数字\n");
    }
    else
    {
        std::printf("最小距离是%d ", min);
        serieNum = se;
        std::printf("匹配到第%d个模板匹配的数字是%d\n", serieNum, serieNum);

        return serieNum;
    }
}

int main()
{

    cv::Mat img;

    using namespace msr::airlib;
    char c = 0;

    msr::airlib::MultirotorRpcLibClient client;
    typedef ImageCaptureBase::ImageRequest ImageRequest;
    typedef ImageCaptureBase::ImageResponse ImageResponse;
    typedef ImageCaptureBase::ImageType ImageType;
    typedef common_utils::FileSystem FileSystem;
    Vector3r ned_origin, ned_curr, ned_target, home_ned, control_origin;

#define CLIP3(_n1, _n,  _n2) {if (_n<_n1) _n=_n1;  if (_n>_n2) _n=_n2;}
    try
    {

        client.confirmConnection();

        client.enableApiControl(true);
        client.armDisarm(true);
        BarometerData curr_bardata;
        BarometerData Barometer_origin;
        Barometer_origin.altitude = client.getBarometerData().altitude;
        BarometerData point_control_bardata;
        std::cout << client.getBarometerData().altitude << std::endl;
        int circle_count = 0;
        int ab_flag = 0;
        int count_go = 0;
        int area_count = 0;
        int fly_mode = 1;

        int rl_flag = 0;
        int num_flag = 1;
        std::wcout << "1" << std::endl;
        ned_target(0) = 240;
        ned_target(1) = 320;
        ned_target(2) = 2.2;

        //pid
        PidController pidX, pidY, pidZ, pidP_X, pidP_Y, pidP_Z, pid_yaw;
        pidP_X.setPoint(ned_target(0), 0.0015, 0, 0.0005);
        pidP_Y.setPoint(ned_target(1), 0.0015, 0, 0.0005);//roll
        pidZ.setPoint(ned_target(2), 0.3, 0, 0.4);
        pidP_Z.setPoint(ned_target(0), 0.005, 0, 0.0003);//delta_throttle


        float takeoffTimeout = 6;
        client.takeoffAsync(takeoffTimeout)->waitOnLastTask();
        client.moveByRollPitchYawrateThrottleAsync(0, 0, 0, 0.6f, 1.0f);
        std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
        // if (fly_mode == 1)

        while (1)
        {

            if (fly_mode == 1)
            {


                std::vector<ImageRequest> request = { ImageRequest("0", ImageType::Scene) };

                const std::vector<ImageResponse>& response = client.simGetImages(request);
                img = cv::imdecode(response.at(0).image_data_uint8, cv::IMREAD_UNCHANGED);
                Mat image = img;

                cv::namedWindow(wndname, 1);
                std::vector<std::vector<Point> > squares;
                findSquares(image, squares);
                drawSquares(image, squares);
                std::cout << "矩形个数" << squares.size() << endl;
                Point p2 = Point(0, 0);
                //cout << "p2.x" << p2.x << endl;
                int chang = 0, kuan = 0;
                for (int k = 0; k < squares.size(); k++)
                {
                    //std::cout << squares[k][0] << endl;
                    //std::cout << squares[k][1] << endl;
                    //std::cout << squares[k][2] << endl;
                    //std::cout << squares[k][3] << endl;
                    /*      circle(image, squares[2][0], 12, Scalar(0, 0, 255), -1);
                          circle(image, squares[1][1], 12, Scalar(255, 0, 255), -1);
                          circle(image, squares[1][2], 12, Scalar(0, 255, 255), -1);
                          circle(image, squares[1][3], 12, Scalar(255, 255, 0), -1);*/
                    cv::imshow(wndname, image);

                    int aa = abs(squares[k][1].x - squares[k][0].x);
                    int bb = abs(squares[k][2].x - squares[k][0].x);
                    int cc = abs(squares[k][1].y - squares[k][0].y);
                    int dd = abs(squares[k][2].y - squares[k][0].y);
                    if (aa >= bb)
                    {
                        chang = aa;
                    }
                    else
                    {
                        chang = bb;
                    }
                    if (cc >= dd)
                    {
                        kuan = cc;
                    }
                    else
                    {
                        kuan = dd;
                    }
                    //std::cout << chang << endl;
                    //std::cout << kuan << endl;
                    int zsx = 0, zsy = 0;
                    int he = squares[k][0].x + squares[k][0].y;
                    for (int i = 0; i < 4; i++)
                    {

                        if (squares[k][i].x + squares[k][i].y <= he)
                        {
                            he = squares[k][i].x + squares[k][i].y;
                            //cout << "he" << he << endl;
                            zsx = squares[k][i].x;
                            zsy = squares[k][i].y;

                        }
                    }
                    //  std::printf("zsx=%d\n", zsx);
                     // std::printf("zsy=%d\n", zsy);

                    Rect rect1(zsx, zsy, chang, kuan);
                    Mat roi1;

                    image(rect1).copyTo(roi1); // copy the region rect1 from the image to roi1
                    //imwrite( "out", image );


                    resize(roi1, roi1, Size(620, 480));
                    //cv::imshow("数字", roi1);
                    Rect rect(100, 80, 400, 320);
                    roi1 = roi1(rect);
                    //if ((char)c == 27)
                       // break;
                    Mat res = roi1;
                    cv::cvtColor(res, res, CV_BGR2GRAY);
                    threshold(res, res, 100, 255, CV_THRESH_BINARY_INV);

                    cutTop(res, res);
                    resize(res, res, Size(620, 480));
                    //cv::imshow("1", res);
                    cv::waitKey(100);


                    //char name[20];
                    //for (int i = 0; i < 10; i++) {
                    //    sprintf_s(name, "%d.jpg", i);
                    //    Mat src = imread(name, CV_LOAD_IMAGE_GRAYSCALE);//读取模板
                    //    int diff;
                    //    cout << "第"<< i <<"张图"<< endl;

                    getSubtract(res, 9);//进行数字识别
                    int zxx = zsx + chang / 2, zxy = zsy + kuan / 2;

                    p2.x = zxx;
                    p2.y = zxy;
                    q = q + 1;
                    if (serieNum == num_flag)
                    {
                        q = 0;
                        std::printf("数字中心横坐标=%d\n", zxx);
                        std::printf("数字中心纵坐标=%d\n", zxy);
                        std::printf("矩形长=%d\n", chang);
                        std::printf("矩形宽=%d\n", kuan);
                        //cv::circle(image, p2, 10, Scalar(255, 0, 0), -1);
                        //cv::imshow(".", image);
                        //cv::waitKey(300);
                        cv::destroyAllWindows();

                        if (abs(p2.y - 240) < 100 && abs(p2.x - 320) < 30)
                        {


                            if (chang < 50)
                            {
                                //往前飞
                                std::cout << "往q飞一点点" << endl;
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, -0.15f, 0.0f, 0.6, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));

                            }
                            else if (chang > 100)
                            {
                                std::cout << "往后飞一点点" << endl;
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.15f, 0.0f, 0.6, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                            }
                            else
                            {
                                fly_mode = 2;
                                std::cout << "转入fly_mode 2" << std::endl;
                                break;
                            }


                        }
                        else
                        {
                            std::cout << "调整" << std::endl;
                            float delta_throttle = (pidP_Z.control(p2.y));
                            float roll = pidP_Y.control(p2.x);
                            float pitch = -0.3;// pidP_X.control(a + b);//ab是椭圆的长短轴

                            CLIP3(-0.5, roll, 0.5);
                            CLIP3(-0.7, pitch, 0.7);
                            CLIP3(0.6, delta_throttle, 0.85);

                            if (p2.y < 180)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.65, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度上调完毕！" << std::endl;
                            }
                            if (p2.y > 300)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.55, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度下调完毕！" << std::endl;
                            }
                            //client.moveByRollPitchYawrateThrottleAsync(-roll, -1.4 * pitch, 0.0f, 1.1 * delta_throttle, 0.5f);
                            client.moveByRollPitchYawrateThrottleAsync(-roll, 0, 0.0f, delta_throttle, 0.5f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                            client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0f, 0.6, 1.0f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                            std::cout << "roll: " << roll << "移动完毕！" << "delta_throttle: " << delta_throttle << std::endl;

                            serieNum = 0;

                        }
                        chang = 0;
                        kuan = 0;
                    }
                    if (q > 5)
                    {
                        fly_mode = 3;
                        rl_flag = 0;
                        q = 0;
                        break;
                    }

                    serieNum = 0;

                }



                // return 0;
            }
            std::cout << "jjjjjjjjjj" << fly_mode << std::endl;

            if (fly_mode == 2)
            {

                int x = 0, y = 0;
                for (int i = 1; i < 500; i++)
                {
                    std::vector<ImageRequest> request = { ImageRequest("0", ImageType::Scene) };
                    const std::vector<ImageResponse>& response = client.simGetImages(request);
                    img = cv::imdecode(response.at(0).image_data_uint8, cv::IMREAD_UNCHANGED);
                    //resize(img, img, Size(1500, 1000));
                    //cv::imshow("数字", roi1);
                   // Rect rect(200, 0, 1100, 1000);
                   // img = img(rect);
                    cv::namedWindow("imageScene");
                    cv::imshow("imageScene", img);
                    //waitKey(800);
                    cv::Mat midImage;
                    cv::cvtColor(img, midImage, CV_BGR2GRAY);//转化边缘检测后的图为灰度图
                    GaussianBlur(midImage, midImage, cv::Size(9, 9), 3, 3);
                    //【3】进行霍夫圆变换
                    std::vector<cv::Vec3f> circles;
                    HoughCircles(midImage, circles, CV_HOUGH_GRADIENT, 1.5, 10, 150, 80, 0, 0);
                    cout << "ys=" << circles.size() << endl;
                    //【4】依次在图中绘制出圆

                    for (size_t i = 0; i < circles.size(); i++)
                    {
                        //参数定义
                        cv::Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
                        int radius = cvRound(circles[i][2]);
                        //绘制圆心
                        cv::circle(img, center, 3, cv::Scalar(0, 255, 0), -1, 8, 0);
                        //绘制圆轮廓
                        cv::circle(img, center, radius, cv::Scalar(155, 50, 255), 3, 8, 0);
                        //打印圆心坐标
                        x = x + cvRound(circles[i][0]);
                        y = y + cvRound(circles[i][1]);
                        std::printf("x = %d,y = %d\n", x, y);

                        //【5】显示效果图  
                        cv::namedWindow("imageScene");
                        cv::imshow("imageScene", img);
                        cv::waitKey(800);
                        cv::destroyAllWindows();

                        if (abs(y - 230) < 30 && abs(x - 320) < 10)
                        {
                            count_go++;
                            if (count_go > 1)
                            {
                                client.hoverAsync();
                                std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                                std::cout << "钻" << std::endl;

                                if (abs(y) > 240)
                                {
                                    client.moveByRollPitchYawrateThrottleAsync(0, -0.15, 0.0f, 0.6, 1.5f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(1.5f));

                                    client.moveByRollPitchYawrateThrottleAsync(0, 0.0, 0.0f, 0.6, 2.0f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(2.0f));
                                    std::cout << "降高钻" << std::endl;
                                    fly_mode = 3;
                                    rl_flag = 2;

                                }
                                else
                                {
                                    client.moveByRollPitchYawrateThrottleAsync(0, -0.15, 0.0f, 0.61, 1.5f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(1.5f));
                                    client.moveByRollPitchYawrateThrottleAsync(0, 0.0, 0.0f, 0.6, 2.0f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(2.0f));
                                    std::cout << "升高钻" << std::endl;
                                    fly_mode = 3;
                                    rl_flag = 2;
                                }
                                client.hoverAsync();
                                std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                                count_go = 0;
                                circle_count++;
                                num_flag++;
                            }
                            else
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0, -0.1, 0.0f, 0.580, 0.1f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.1f));
                            }
                        }
                        else
                        {
                            if (y < 240)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.65, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度上调完毕！" << std::endl;
                            }
                            if (y > 280)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.55, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度下调完毕！" << std::endl;
                            }
                            // 调整使无人机正对圆心位置
                            std::cout << "调整" << std::endl;
                            float delta_throttle = (pidP_Z.control(y));
                            float roll = pidP_Y.control(x);
                            float pitch = -0.3;// pidP_X.control(a + b);//ab是椭圆的长短轴

                            CLIP3(-0.5, roll, 0.5);
                            CLIP3(-0.7, pitch, 0.7);
                            CLIP3(0.6, delta_throttle, 0.85);

                            client.moveByRollPitchYawrateThrottleAsync(-roll, -0.05, 0.0f, delta_throttle, 0.5f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                            client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0f, 0.6, 1.0f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                            std::cout << "roll: " << roll << "移动完毕！" << "delta_throttle: " << delta_throttle << std::endl;
                        }
                        client.hoverAsync();
                        x = 0;
                        y = 0;
                        break;

                    }
                    if (fly_mode == 3) { break; }

                }
            }
            std::cout << "kkkkkk" << fly_mode << std::endl;

            if (fly_mode == 3)
            {
                client.hoverAsync();
                // client.moveByRollPitchYawrateThrottleAsync(0, 0, 0, 0.55f, 0.3f);
                // std::this_thread::sleep_for(std::chrono::duration<double>(0.3f));
                std::cout << "未检测到目标" << std::endl;


                if (rl_flag == 0)//左移
                {
                    s = s + 1;
                    std::cout << "左移" << std::endl;

                    client.moveByRollPitchYawrateThrottleAsync(-0.15, 0, 0.00, 0.6, 0.4f);
                    std::this_thread::sleep_for(std::chrono::duration<double>(0.4f));
                    client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.00, 0.6, 0.3f);
                    std::this_thread::sleep_for(std::chrono::duration<double>(0.3f));
                    if (s > 2)
                    {
                        curr_bardata.altitude = client.getBarometerData().altitude;
                        float mesurementHeight = curr_bardata.altitude;
                        float outH;
                        float targetHeight = 127;
                        outH = 0.6 + 0.03 * (targetHeight - mesurementHeight);
                        CLIP3(0.5, outH, 0.8)
                            std::cout << outH << std::endl;
                        client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0, outH, 2.0f);
                        std::this_thread::sleep_for(std::chrono::duration<double>(2.0f));
                        client.hoverAsync();
                        std::cout << "sssss" << std::endl;
                        fly_mode = 4;
                        s = 0;
                    }
                }



                if (rl_flag == 1) //右移
                {
                    p = p + 1;
                    std::cout << "右移" << std::endl;

                    client.moveByRollPitchYawrateThrottleAsync(0.15, 0, 0.00, 0.6, 0.45f);
                    std::this_thread::sleep_for(std::chrono::duration<double>(0.45f));
                    client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.00, 0.6, 0.4f);
                    std::this_thread::sleep_for(std::chrono::duration<double>(0.4f));

                    if (p > 3)
                    {
                        client.hoverAsync();
                        curr_bardata.altitude = client.getBarometerData().altitude;
                        float mesurementHeight = curr_bardata.altitude;
                        float outH;
                        float targetHeight = 127;
                        outH = 0.6 + 0.03 * (targetHeight - mesurementHeight);
                        CLIP3(0.5, outH, 0.8)
                            std::cout << outH << std::endl;
                        client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0, outH, 2.0f);
                        std::this_thread::sleep_for(std::chrono::duration<double>(2.0f));
                        std::cout << "pppppp" << std::endl;
                        fly_mode = 5;
                        // rl_flag = 2;
                        p = 0;
                    }

                }
                if (rl_flag == 2) //不动
                {
                    while (1)
                    {
                        curr_bardata.altitude = client.getBarometerData().altitude;
                        float mesurementHeight = curr_bardata.altitude;
                        float outH;
                        float targetHeight = 127;

                        outH = 0.6 + 0.03 * (targetHeight - mesurementHeight);
                        CLIP3(0.4, outH, 0.8)
                            std::cout << outH << std::endl;
                        client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0, outH, 0.5f);
                        std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                        if (abs(targetHeight - mesurementHeight) < 0.3)
                        {
                            break;
                        }
                    }
                    client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.00, 0.6, 0.8f);
                    std::this_thread::sleep_for(std::chrono::duration<double>(0.8f));
                    fly_mode = 1;

                    cout << "num_flag" << num_flag << endl;
                }


            }

            if (fly_mode == 4)
            {
                std::vector<ImageRequest> request = { ImageRequest("0", ImageType::Scene) };

                const std::vector<ImageResponse>& response = client.simGetImages(request);
                img = cv::imdecode(response.at(0).image_data_uint8, cv::IMREAD_UNCHANGED);
                Mat image = img;
                cv::namedWindow(wndname, 1);
                std::vector<std::vector<Point> > squares;
                findSquares(image, squares);
                drawSquares(image, squares);
                std::cout << "矩形个数" << squares.size() << endl;
                Point p2 = Point(0, 0);
                //cout << "p2.x" << p2.x << endl;
                int chang = 0, kuan = 0;

                for (int k = 0; k < squares.size(); k++)
                {
                    //std::cout << squares[k][0] << endl;
                    //std::cout << squares[k][1] << endl;
                    //std::cout << squares[k][2] << endl;
                    //std::cout << squares[k][3] << endl;
                    /*      circle(image, squares[2][0], 12, Scalar(0, 0, 255), -1);
                          circle(image, squares[1][1], 12, Scalar(255, 0, 255), -1);
                          circle(image, squares[1][2], 12, Scalar(0, 255, 255), -1);
                          circle(image, squares[1][3], 12, Scalar(255, 255, 0), -1);*/
                    cv::imshow(wndname, image);

                    int aa = abs(squares[k][1].x - squares[k][0].x);
                    int bb = abs(squares[k][2].x - squares[k][0].x);
                    int cc = abs(squares[k][1].y - squares[k][0].y);
                    int dd = abs(squares[k][2].y - squares[k][0].y);
                    if (aa >= bb)
                    {
                        chang = aa;
                    }
                    else
                    {
                        chang = bb;
                    }
                    if (cc >= dd)
                    {
                        kuan = cc;
                    }
                    else
                    {
                        kuan = dd;
                    }
                    //std::cout << chang << endl;
                    //std::cout << kuan << endl;
                    int zsx = 0, zsy = 0;
                    int he = squares[k][0].x + squares[k][0].y;
                    for (int i = 0; i < 4; i++)
                    {

                        if (squares[k][i].x + squares[k][i].y <= he)
                        {
                            he = squares[k][i].x + squares[k][i].y;
                            //cout << "he" << he << endl;
                            zsx = squares[k][i].x;
                            zsy = squares[k][i].y;

                        }
                    }
                    //  std::printf("zsx=%d\n", zsx);
                     // std::printf("zsy=%d\n", zsy);

                    Rect rect1(zsx, zsy, chang, kuan);
                    Mat roi1;

                    image(rect1).copyTo(roi1); // copy the region rect1 from the image to roi1
                    //imwrite( "out", image );


                    resize(roi1, roi1, Size(620, 480));
                    //cv::imshow("数字", roi1);
                    Rect rect(100, 80, 400, 320);
                    roi1 = roi1(rect);
                    //if ((char)c == 27)
                       // break;
                    Mat res = roi1;
                    cv::cvtColor(res, res, CV_BGR2GRAY);
                    threshold(res, res, 100, 255, CV_THRESH_BINARY_INV);

                    cutTop(res, res);
                    resize(res, res, Size(620, 480));
                    //cv::imshow("1", res);
                    cv::waitKey(100);


                    //char name[20];
                    //for (int i = 0; i < 10; i++) {
                    //    sprintf_s(name, "%d.jpg", i);
                    //    Mat src = imread(name, CV_LOAD_IMAGE_GRAYSCALE);//读取模板
                    //    int diff;
                    //    cout << "第"<< i <<"张图"<< endl;

                    getSubtract(res, 9);//进行数字识别
                    int zxx = zsx + chang / 2, zxy = zsy + kuan / 2;

                    p2.x = zxx;
                    p2.y = zxy;
                    q = q + 1;
                    if (serieNum == num_flag)
                    {

                        std::printf("数字中心横坐标=%d\n", zxx);
                        std::printf("数字中心纵坐标=%d\n", zxy);
                        std::printf("矩形长=%d\n", chang);
                        std::printf("矩形宽=%d\n", kuan);
                        q = 0;
                        //cv::circle(image, p2, 10, Scalar(255, 0, 0), -1);
                        //cv::imshow(".", image);
                        //cv::waitKey(300);
                        cv::destroyAllWindows();

                        if (abs(p2.y - 240) < 100 && abs(p2.x - 320) < 30)
                        {
                            if (chang < 80)
                            {
                                //往前飞
                                std::cout << "往q飞一点点" << endl;
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, -0.15f, 0.0f, 0.65, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));

                            }
                            else if (chang > 100)
                            {
                                std::cout << "往后飞一点点" << endl;
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.15f, 0.0f, 0.65, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                            }
                            else
                            {
                                fly_mode = 2;
                                std::cout << "转入fly_mode 2" << std::endl;

                                break;
                            }


                        }
                        else
                        {
                            std::cout << "调整" << std::endl;
                            float delta_throttle = (pidP_Z.control(p2.y));
                            float roll = pidP_Y.control(p2.x);
                            float pitch = -0.3;// pidP_X.control(a + b);//ab是椭圆的长短轴

                            CLIP3(-0.5, roll, 0.5);
                            CLIP3(-0.7, pitch, 0.7);
                            CLIP3(0.6, delta_throttle, 0.85);

                            if (p2.y < 180)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.65, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度上调完毕！" << std::endl;
                            }
                            if (p2.y > 300)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.55, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度下调完毕！" << std::endl;
                            }
                            //client.moveByRollPitchYawrateThrottleAsync(-roll, -1.4 * pitch, 0.0f, 1.1 * delta_throttle, 0.5f);
                            client.moveByRollPitchYawrateThrottleAsync(-roll, 0, 0.0f, delta_throttle, 0.5f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                            client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0f, 0.6, 1.0f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                            std::cout << "roll: " << roll << "移动完毕！" << "delta_throttle: " << delta_throttle << std::endl;

                            // serieNum = 0;

                        }
                    }
                    if (q > 5)
                    {
                        fly_mode = 3;
                        rl_flag = 1;
                        q = 0;
                    }
                    // serieNum = 0;

                }



                // return 0;
            }

            if (fly_mode == 5)
            {
                std::cout << "fly_mode=5" << std::endl;
                int x = 0, y = 0;
                for (int i = 1; i < 500; i++)
                {
                    std::vector<ImageRequest> request = { ImageRequest("0", ImageType::Scene) };
                    const std::vector<ImageResponse>& response = client.simGetImages(request);
                    img = cv::imdecode(response.at(0).image_data_uint8, cv::IMREAD_UNCHANGED);
                    //resize(img, img, Size(1500, 1000));
                    //cv::imshow("数字", roi1);
                   // Rect rect(200, 0, 1100, 1000);
                   // img = img(rect);
                    cv::namedWindow("imageScene");
                    cv::imshow("imageScene", img);
                    //waitKey(800);
                    cv::Mat midImage;
                    cv::cvtColor(img, midImage, CV_BGR2GRAY);//转化边缘检测后的图为灰度图
                    GaussianBlur(midImage, midImage, cv::Size(9, 9), 3, 3);
                    //【3】进行霍夫圆变换
                    std::vector<cv::Vec3f> circles;
                    HoughCircles(midImage, circles, CV_HOUGH_GRADIENT, 1.5, 10, 150, 80, 0, 0);
                    cout << "ys=" << circles.size() << endl;
                    //【4】依次在图中绘制出圆

                    for (size_t i = 0; i < circles.size(); i++)
                    {
                        //参数定义
                        cv::Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
                        int radius = cvRound(circles[i][2]);
                        //绘制圆心
                        cv::circle(img, center, 3, cv::Scalar(0, 255, 0), -1, 8, 0);
                        //绘制圆轮廓
                        cv::circle(img, center, radius, cv::Scalar(155, 50, 255), 3, 8, 0);
                        //打印圆心坐标
                        x = x + cvRound(circles[i][0]);
                        y = y + cvRound(circles[i][1]);
                        std::printf("x = %d,y = %d\n", x, y);

                        //【5】显示效果图  
                        cv::namedWindow("imageScene");
                        cv::imshow("imageScene", img);
                        cv::waitKey(800);
                        cv::destroyAllWindows();

                        if (abs(y - 230) < 30 && abs(x - 320) < 10)
                        {
                            count_go++;
                            if (count_go > 1)
                            {
                                client.hoverAsync();
                                std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                                std::cout << "钻" << std::endl;

                                if (abs(y) > 240)
                                {
                                    client.moveByRollPitchYawrateThrottleAsync(0, -0.15, 0.0f, 0.6, 1.5f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(1.5f));

                                    client.moveByRollPitchYawrateThrottleAsync(0, 0.0, 0.0f, 0.6, 2.0f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(2.0f));
                                    std::cout << "降高钻" << std::endl;
                                    fly_mode = 1;
                                    rl_flag = 2;

                                }
                                else
                                {
                                    client.moveByRollPitchYawrateThrottleAsync(0, -0.15, 0.0f, 0.6, 1.5f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(1.5f));
                                    client.moveByRollPitchYawrateThrottleAsync(0, 0.0, 0.0f, 0.6, 2.0f);
                                    std::this_thread::sleep_for(std::chrono::duration<double>(2.0f));
                                    std::cout << "升高钻" << std::endl;
                                    fly_mode = 1;
                                    rl_flag = 2;
                                }
                                client.hoverAsync();
                                std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                                count_go = 0;
                                circle_count++;
                                num_flag++;
                            }
                            else
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0, -0.1, 0.0f, 0.580, 0.1f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.1f));
                            }
                        }
                        else
                        {
                            if (y < 240)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.65, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度上调完毕！" << std::endl;
                            }
                            if (y > 280)
                            {
                                client.moveByRollPitchYawrateThrottleAsync(0.0f, 0.0f, 0.0f, 0.55, 0.5f);
                                std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                                std::cout << "高度下调完毕！" << std::endl;
                            }
                            // 调整使无人机正对圆心位置
                            std::cout << "调整" << std::endl;
                            float delta_throttle = (pidP_Z.control(y));
                            float roll = pidP_Y.control(x);
                            float pitch = -0.3;// pidP_X.control(a + b);//ab是椭圆的长短轴

                            CLIP3(-0.5, roll, 0.5);
                            CLIP3(-0.7, pitch, 0.7);
                            CLIP3(0.6, delta_throttle, 0.85);

                            client.moveByRollPitchYawrateThrottleAsync(-roll, -0.05, 0.0f, delta_throttle, 0.5f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(0.5f));
                            client.moveByRollPitchYawrateThrottleAsync(0, 0, 0.0f, 0.6, 1.0f);
                            std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));
                            std::cout << "roll: " << roll << "移动完毕！" << "delta_throttle: " << delta_throttle << std::endl;
                        }
                        client.hoverAsync();
                        x = 0;
                        y = 0;
                        break;

                    }
                    if (fly_mode == 1) { break; }

                }
            }


        }





        client.enableApiControl(true);
        auto position = client.getMultirotorState().getPosition();
        float z = position.z(); // current position (NED coordinate system).  
        const float speed = 4.0f;
        const float size = 11.0f;
        const float duration = size / speed;
        DrivetrainType driveTrain = DrivetrainType::ForwardOnly;
        YawMode yaw_mode(true, 0);

        client.moveByRollPitchYawrateThrottleAsync(0, 0, 0, 0.6f, 1.0f);
        std::this_thread::sleep_for(std::chrono::duration<double>(1.0f));


        std::cout << "Press Enter to land" << std::endl; std::cin.get();
        client.landAsync()->waitOnLastTask();

        std::cout << "Press Enter to disarm" << std::endl; std::cin.get();
        client.armDisarm(false);

    }

    catch (rpc::rpc_error& e) {
        std::string msg = e.get_error().as<std::string>();
        std::cout << "Exception raised by the API, something went wrong." << std::endl << msg << std::endl;
    }

    return 0;
}
